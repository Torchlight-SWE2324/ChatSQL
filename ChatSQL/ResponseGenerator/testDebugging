import os
import json
import streamlit as st

from guiUtils import generateUpsertCommands, upsert, getDictionariesFolderPath
from txtai import Embeddings

# contenuto del file va sostituito in "guiEmbedder.py" e runnato direttamente il file

def loadIndex(emb, dictionary_file_name):
    emb.load(f"indexes/{os.path.splitext(dictionary_file_name)[0]}")


def createIndex(dictionary_path):
    st.session_state.upsert_commands = generateUpsertCommands(dictionary_path)
    st.session_state.emb = upsert(st.session_state.upsert_commands)
    file_name = os.path.basename(dictionary_path)
    st.session_state.emb.save(f"indexes/{os.path.splitext(file_name)[0]}")
    st.session_state.emb.close()


def deleteIndex(dirPath, filename_to_delete_without_extension):
    indexes_folder_path = os.path.join(dirPath, "indexes")
    index_folder_to_delete_path = os.path.join(indexes_folder_path, filename_to_delete_without_extension)

    for file_to_delete in os.listdir(index_folder_to_delete_path):
        file_to_delete_path = os.path.join(index_folder_to_delete_path, file_to_delete)
        os.remove(file_to_delete_path)
    os.rmdir(index_folder_to_delete_path)


def generatePrompt(emb, user_query, dictionary_name):
    #set logged_in to true
    demo_login = False
    # Creazione prompt per Admin
    if demo_login:
        embedder_search_result = emb.search(f"SELECT score, text, table_name, field_name, field_description FROM txtai WHERE similar('{user_query}') AND score > 0.01 GROUP BY table_name, field_name", limit=50)

        dictionary_path = os.path.join(getDictionariesFolderPath(), dictionary_name)

        with open(dictionary_path, 'r') as dictionary_file:
            data = json.load(dictionary_file)

        tables_with_fields = {}

        for result in embedder_search_result:
            table_name = result['table_name']
            field_name = result['field_name']
            field_description = result['field_description']
            score = result['score']

            if table_name not in tables_with_fields:
                tables_with_fields[table_name] = []

            tables_with_fields[table_name].append((field_name, field_description, score ))

        prompt = "Similarity score with the user interrogation of each field in the database:\n\n"

        for table_name, fields in tables_with_fields.items():
            prompt += f"TABLE '{table_name}':\n"
            for field, description, score in fields:
                prompt += f"- FIELD: {field} {' '*(max(len(field), 12) - len(field))} | SCORE: {score:.5f} | DESCRIPTION: {description}\n"

        return prompt

    # Creazione prompt per User
    else:
        embedder_search_result = emb.search(f"SELECT score, text, table_name, field_name, field_description, field_references FROM txtai WHERE similar('{user_query}') AND score > 0.25 GROUP BY table_name, field_name", limit=50)
        
        prompt = ""
        
        tables_with_fields = {}
        referencies_list = {}

        for result in embedder_search_result:
            table_name = result['table_name']
            field_name = result['field_name']
            field_description = result['field_description']
            if # controlla se ci sono references 
                ref_table_name = result['field_references']['table_name']
                ref_field_name = result['field_references']['field_name']

            if table_name not in tables_with_fields:
                tables_with_fields[table_name] = []
            tables_with_fields[table_name].append((field_name, field_description))

            if table_name not in referencies_list:
                referencies_list[table_name] = []
            referencies_list[table_name].append((table_name, field_name, ref_table_name, ref_field_name))


        
        if len(tables_with_fields) > 0:
            prompt = "The data base contain the following tables:\n\n"

            for table_name, fields in tables_with_fields.items():
                prompt += f"TABLE '{table_name}':\n"
                for field, description, score in fields:
                    prompt += f"- FIELD: {field} {' '*(max(len(field), 12) - len(field))} | DESCRIPTION: {description}\n"

            if len(referencies_list) > 0:
                prompt += "and the database contains the following relationships:\n"
                for table_name, fields in tables_with_fields.items():
                    prompt += f"TABLE '{table_name}':\n"
                    for tname, fname, rtname, rfname in fields:
                        prompt += f"{tname}.{fname} references {rtname}.{rfname}\n"

            prompt += f"\nGenerate the SQL query equivalent to: {user_query}"
        
        else:
            prompt = "No relevant information was found regarding your request. \nPlease try again with a different query. \nPlease note that this application is designed to handle requests that can be translated into a SQL query."
        
        return prompt

if __name__ == "__main__":

    emb = Embeddings({"path": "sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2", "content": True})

    with open("C:/Users/taore/Documents/Codice/SWE/ChatSQL/ChatSQL/JSON/auction.json", 'r') as file:
        data = json.load(file)

    commands = []

    for table in data["tables"]:
        table_name = table["name"]
        table_description = table["table-description"]

        for column in table["columns"]:
            field_name = column["name"]
            type = column["type"]
            references = column["references"]
            description = column["description"]

            # Create the emb.upsert command
            dictionary = {"table_name": table_name, "table_description": table_description, "field_name": field_name,
                          "field_type": type, "field_references": references, "field_description": description}

            commands.append(dictionary)
    

    emb.index([{"table_name": command["table_name"],
                "table_description": command["table_description"],
                "field_name": command["field_name"],
                "field_type": command["field_type"],
                "field_references": command["field_references"],
                "field_description": command["field_description"],
                "text": command["field_description"]} for command in commands])    # va cambiato il campo text dentro emb.index
    
    print(generatePrompt(emb, user_query="item", dictionary_name="C:/Users/taore/Documents/Codice/SWE/ChatSQL/ChatSQL/JSON/auction.json"))







    # utente può cambiare il dizionario corrente
    # bottone selezione nuovo dizionario corrente
    # controller riceve il segnale di cambio dizionario corrente
    # nel model va cambiato l'index dell'embedding 
    # emb.load(va a recuperare l'index dentro la cartella index)


    # Caricamento
    
    # DizionariSalvatiModel
    # getDizionari() aprire la cartella database e leggere da lì la lista //evito così il sigleton
    # crei una lista che ritorni al controller -> a sua volta li mostra sulla view
    
    # isLogged session state
    # percorso corrente session state